# Attitude-Stability-of-tilt-rotor-UAV-during-Obstacle-Avoidance-and-Transition-mode

#####
##plot through working window
>> x1=out.x; x0=x1.Data; y1=out.y; y0=y1.Data;
>> plot(x0,y0);
>> plot(x0,y0);
>> hold on
>>  a0  =  7.5087;  
a1=-2.1673;
b1  =  4.7392;   
a2   = -0.2270 ;   
b2  =  -0.5158 ;  
a3  =  0.1598  ;  
b3  =  -0.3852  ;  
a4  =  0.1270  ;  
b4  =  0.2219  ;   
a5  =  -0.2227 ;   
b5  =  0.0365 ;    
w  =   0.3127  ;
xg=linspace(0,20,100);
yg= a0 + a1*cos(xg*w) + b1*sin(xg*w) + a2*cos(2*xg*w) + b2*sin(2*xg*w) + a3*cos(3*xg*w) + b3*sin(3*xg*w) + a4*cos(4*xg*w) + b4*sin(4*xg*w) + a5*cos(5*xg*w) + b5*sin(5*xg*w);
>> plot(xg,yg);
>> hold on
Data.Obs(1).S = [1,4; 2,4; 2,1; 1,1;1,4]; Data.Obs(2).S = [3,6; 4,6; 4,3; 3,3;3,6]; Data.Obs(3).S = [6,4; 7,4; 7,1; 6,1;6,4]; Data.Obs(4).S = [8,10; 9,10; 9,5; 8,5;8,10]; Data.Obs(5).S = [10,14; 14,14; 14,12; 10,12;10,14]; Data.Obs(6).S = [14,8; 18,8; 18,6; 14,6;14,8]; % 创建一个新的图形窗口 
hold on; 
for i = 1:length(Data.Obs)
xy = Data.Obs(i).S; 
plot(xy(:,1), xy(:,2), 'LineWidth', 2, 'Color', rand(1,3)); 
end

##### GA 
This readme document is intended to outline and explain the main features and implementation details of the MATLAB code. The code implements a genetic algorithm (GA) based path planning optimization algorithm to find the optimal or sub-optimal path from the starting point to the end point in an environment with multiple obstacles.
1. Code overview
The code first sets the necessary parameters and data structures through a series of initialization steps, including the location of obstacles, starting and ending coordinates, population size, chromosome length, number of iterations, mutation probability, and crossover probability. The code then continuously evolves the population through genetic algorithms to find a path that does not intersect with obstacles and is as optimized as possible.
2. Main steps
2.1 Initialization
• Use clc; clear;  close all;  warning off; Clear the command window, workspace, and graphics window, and turn off MATLAB warnings.
• Use addpath(genpath(pwd)); Add the current directory and its subdirectories to the path of MATLAB so that custom functions can be loaded and invoked.
• Set the Data structure Data, including boundary B, starting point and ending point S_E, population size, chromosome length, etc.
• Define obstacle Obs, with each obstacle defined by a series of vertices arranged in clockwise order.
2.2 Initial population generation
• Call intpop function to generate initial population. This function generates an initial solution set based on the data provided, such as population size and chromosome length.
2.3 Checking and Repairing Paths
• Use the check_crossing function on each individual (that is, each path) to check for an intersection with an obstacle.
If an intersection is found, a new waypoint is generated using the newpop function until the path no longer intersects with any obstacles.
2.4 Evolutionary process
• Through multiple iterations, using the ideas of genetic algorithms (selection, crossover, variation) to optimize the population.
• Calculate the fitness of an individual using the cal_Fitness function.
• Use the environmental_sele function to select the environment and keep good individuals in the external archive set Qop.
In non-final iterations, a new population is generated by tournament selection binary_tournament_selection, crosscross_mutation, and smoothing operation delete_point.
2.5 Result output and visualization
• After the last iteration, the non-dominant individual (i.e. the optimal solution set) is selected for output.
Use the plotting function to draw the optimal path and obstacles into the graph window so you can visually view the results.
3. Precautions
• The Goals function in the code is used to calculate the value of the objective function, that is, to evaluate the pros and cons of the path.
4. Conclusion
The MATLAB code implements a path planning optimization algorithm based on genetic algorithm, which can find the optimal path from the starting point to the end point in the environment with complex obstacles. By iterating and evolving the population, the algorithm can gradually optimize the path until it finds an optimal or suboptimal solution that meets the requirements
